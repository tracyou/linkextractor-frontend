input AnnotatedArticleInput {
  articles: [ArticleInput!]!
  isPublished: Boolean
  lawId: UUID!
  title: String!
}

type Annotation {
  comment: String
  createdAt: DateTime!
  definition: String
  id: UUID!
  laws: Law!
  matter: Matter!
  relationSchema: RelationSchema!
  text: String!
  updatedAt: DateTime!
}

input AnnotationInput {
  comment: String
  definition: String
  matterId: UUID!
  relationSchemaId: UUID!
  text: String!
}

type Article {
  annotations: [Annotation!]!
  id: UUID!
  jsonText: JSON
  law: Law!
  text: String
  title: String
}

input ArticleInput {
  annotations: [AnnotationInput!]!
  articleId: UUID!
  jsonText: JSON
  text: String!
  title: String!
}

input CreatePancakeInput {
  diameter: Int!
}

input CreatePancakeStackInput {
  name: String!
  pancakes: [ID!]!
}

scalar Date

scalar DateTime

"""
Arbitrary data encoded in JavaScript Object Notation. See https://www.json.org.
"""
scalar JSON

type Law {
  articles: [Article!]!
  createdAt: DateTime!
  id: UUID!
  isPublished: Boolean!
  title: String!
  updatedAt: DateTime!
}

type LawAnnotationPivot {
  comment: String
  cursorIndex: Int!
  id: UUID!
}

type Matter {
  annotations: [Annotation!]!
  color: String!
  createdAt: DateTime!
  id: UUID!
  matterRelations: [MatterRelation!]!
  name: String!
  updatedAt: DateTime!
}

type MatterRelation {
  createdAt: DateTime!
  description: String
  id: UUID!
  matterRelationSchema: MatterRelationSchema!
  relatedMatter: Matter!
  relation: MatterRelationEnum!
  updatedAt: DateTime!
}

"""Matter relation enum"""
enum MatterRelationEnum {
  """Requires one"""
  REQUIRES_ONE

  """Requires one or more"""
  REQUIRES_ONE_OR_MORE

  """Requires zero or more"""
  REQUIRES_ZERO_OR_MORE

  """Requires zero or one"""
  REQUIRES_ZERO_OR_ONE
}

input MatterRelationInput {
  description: String
  relatedMatterId: UUID!
  relation: MatterRelationEnum!
}

type MatterRelationSchema {
  createdAt: DateTime!
  id: UUID!
  matter: Matter!
  relationSchema: RelationSchema!
  relations: [MatterRelation!]!
  schemaLayout: String!
  updatedAt: DateTime!
}

input MatterRelationSchemaInput {
  matterId: UUID!
  relationSchemaId: UUID!
}

type MatterRelationType {
  key: MatterRelationEnum!
  value: String!
}

type Mutation {
  createPancake(input: CreatePancakeInput!): Pancake!
  createPancakeStack(input: CreatePancakeStackInput!): PancakeStack!
  deletePancake(id: ID!): Boolean!
  deletePancakeStack(id: ID!): Boolean!
  publishRelationSchema(id: UUID!): RelationSchema!
  saveAnnotatedLaw(input: AnnotatedArticleInput!): Law!
  saveFileXml(input: XmlFileInput!): XmlFile!
  saveMatterRelationSchema(input: SaveMatterRelationSchemaInput!): MatterRelationSchema!
  updatePancake(input: UpdatePancakeInput!): Pancake!
  updatePancakeStack(input: UpdatePancakeStackInput!): PancakeStack!
}

"""Allows ordering a list of records."""
input OrderByClause {
  """The column that is used for ordering."""
  column: String!

  """The direction that is used for ordering."""
  order: SortOrder!
}

"""
Aggregate functions when ordering by a relation without specifying a column.
"""
enum OrderByRelationAggregateFunction {
  """Amount of items."""
  COUNT
}

"""
Aggregate functions when ordering by a relation that may specify a column.
"""
enum OrderByRelationWithColumnAggregateFunction {
  """Average."""
  AVG

  """Amount of items."""
  COUNT

  """Maximum."""
  MAX

  """Minimum."""
  MIN

  """Sum."""
  SUM
}

type Pancake {
  createdAt: DateTime!
  diameter: Int!
  id: ID!
  stack: PancakeStack
  updatedAt: DateTime!
}

type PancakeStack {
  createdAt: DateTime!
  id: ID!
  name: String!
  pancakes: [Pancake!]!
  updatedAt: DateTime!
}

type Query {
  articles: [Article!]!
  fileXmls: [XmlFile!]!
  law(id: UUID!): Law!
  laws: [Law!]!
  matter(id: UUID!): Matter!
  matterRelationSchema(input: MatterRelationSchemaInput!): MatterRelationSchema
  matterRelationSchemas: [MatterRelationSchema!]!
  matterRelationTypes: [MatterRelationType!]!
  matters: [Matter!]!
  pancakeById(id: ID!): Pancake!
  pancakeStackById(id: ID!): PancakeStack!
  pancakeStacks: [PancakeStack!]!
  pancakes: [Pancake!]!
  relationSchema(id: UUID!): RelationSchema!
  relationSchemas: [RelationSchema!]!
}

type RelationSchema {
  annotations: [Annotation!]!
  createdAt: DateTime!
  expiredAt: DateTime
  id: UUID!
  isPublished: Boolean!
  matterRelationSchemas: [MatterRelationSchema!]!
  updatedAt: DateTime!
}

input SaveMatterRelationSchemaInput {
  matterId: UUID!
  matterRelationSchemaId: UUID
  relationSchemaId: UUID
  relations: [MatterRelationInput!]!
  schemaLayout: String!
}

"""Directions for ordering a list of records."""
enum SortOrder {
  """Sort records in ascending order."""
  ASC

  """Sort records in descending order."""
  DESC
}

"""
Specify if you want to include or exclude trashed results from a query.
"""
enum Trashed {
  """Only return trashed results."""
  ONLY

  """Return both trashed and non-trashed results."""
  WITH

  """Only return non-trashed results."""
  WITHOUT
}

scalar UUID

input UpdatePancakeInput {
  diameter: Int!
  id: ID!
}

input UpdatePancakeStackInput {
  id: ID!
  name: String!
  pancakes: [ID!]!
}

type XmlFile {
  content: String!
  id: ID!
  title: String!
}

input XmlFileInput {
  content: String!
  title: String!
}